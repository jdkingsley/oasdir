{
    "collab_server" : "",
    "contents" : "#' Return the \\emph{National Average Wage Index} data set.\n#'\n#' The \\emph{National Average Wage Index} is used to normalize wages across\n#' different years. Wage indexing depends on the year in which a person is\n#' first elgible to receive OASDI benefits. The year of first elgibility for\n#' OASDI is at age 62. An individuals earnings are always indexed to the average\n#' wage level two years prior to the year of first eligibility. This is called\n#' the indexing year. Thus, for a person reaching age 62 in 2017, the personâ€™s\n#' earnings would be indexed to the average wage index for 2015, which is the\n#' indexing year. A table of Average Wage Indexes is available on the Social\n#' Security web site. This data set comes from there, but it is not a real time\n#' fetch, so the data is current up to the time that this package was created.\n#' In order to determine the Average Indexed Monthly Earnings when the indexing\n#' year is beyond the last year in the AWI data, the data is fit with a model\n#' which is used to project future wage index values. If no endYear is provided\n#' the function returns the data set of measured values without any projected\n#' values.\n#'\n#' @param endYear the last year to include in the returned data set\n#' @return the AWI data set\n#' @examples\n#' getAwiSet(endYear = 2025)\n#' getAwiSet()\n#'\n#' @export\ngetAwiSet <- function(endYear = NULL) {\n  if(is.null(endYear)) {\n    return(awi)\n  }\n\n  beginYear <- max(awi$Year, na.rm = TRUE) + 1\n  if(endYear <= beginYear) {\n    return(awi[awi$Year <= endYear,])\n  } else {\n    awiChunk <- data.frame(Year = beginYear:endYear,\n                           AWI = predict(awiMars, newdata = beginYear:endYear))\n    awiChunk$`Annual change` = c((awiChunk$AWI[1] - awi$AWI[nrow(awi)]) /\n                                   awi$AWI[nrow(awi)],\n                                 (awiChunk$AWI[2:(nrow(awiChunk))] -\n                                    awiChunk$AWI[1:(nrow(awiChunk) - 1)]) /\n                                   awiChunk$AWI[1:(nrow(awiChunk) - 1)])\n    awiChunk$Status = \"Predicted\"\n\n    return(rbind(awi, awiChunk))\n  }\n}\n\n\n\n\n#' Return the \\emph{Benefit Bases} data set.\n#'\n#' The \\emph{Benefit Bases} data contains the maximum Socal\n#' Security taxable wages for each year. Earnings above this\n#' value were not taxed and are also not included in the\n#' calculation of OASDI benefits. A table of Benefit Bases is\n#' available on the Social Security web site. This data set comes\n#' from there, but it is not a real time fetch, so the data is\n#' current up to the time that this package was created. In order\n#' to determine the Benefit Base for a year that is beyond the\n#' last year in the Benefit Bases data, the data is fit with a model\n#' which is used to project future Benefit Base values. If no endYear\n#' is provided the function returns the data set of measured values\n#' without any projected values.\n#'\n#' @param endYear the last year to include in the returned data set\n#' @return the Benefit Bases data set\n#' @examples\n#' getBenefitBasesSet(endYear = 2025)\n#' getBenefitBasesSet()\n#'\n#' @export\n# Return benefitBases to end year\ngetBenefitBasesSet <- function(endYear = NULL){\n  if(is.null(endYear)) {\n    return(benefitBases)\n  }\n\n  beginYear <- max(benefitBases$Year, na.rm = TRUE) + 1\n  if(endYear <= beginYear) {\n    return(benefitBases[benefitBases$Year <= endYear,])\n  } else {\n    benefitBasesChunk <- data.frame(Year = beginYear:endYear,\n                                    Amount = predict(benefitBasesMars,\n                                                     newdata = beginYear:endYear))\n    benefitBasesChunk$Status = \"Predicted\"\n\n    return(rbind(benefitBases, benefitBasesChunk))\n  }\n}\n\n\n\n\n#' @export\n# Return CPIW to end year\ngetCPIWSet <- function(endYear = NULL){\n  if(is.null(endYear)) {\n    return(cpiw)\n  }\n\n  endDate <- lubridate::make_date(year = endYear, month = 12)\n  beginDate <- lubridate::add_with_rollback(max(cpiw$Date, na.rm = TRUE),\n                                            lubridate::as.period(1, unit = \"month\"))\n  if(endDate <= beginDate) {\n    return(cpiw[cpiw$Date <= endDate, ])\n  } else {\n    # Convert Dec of endYear to months since Jan 1974\n    # (the model was constructed using months since 1974)\n    endMonth <- (endYear - 1973) * 12 - 1\n    # Create chunk from max of cpiw$Date to Dec of endYear\n    cpiwChunk <- data.frame(Date = seq(from = beginDate, to = endDate, by = \"month\"),\n                            CPIW = predict(cpiwMars, newdata = (nrow(cpiw)):endMonth),\n                            Status = \"Predicted\")\n    return(rbind(cpiw, cpiwChunk))\n  }\n}\n\n\n\n\n#' @export\n# Return pia bend points to end year\ngetPiaBendPtsSet <- function(endYear = endYear){\n\n  beginYear <- max(piaBends$Year, na.rm = TRUE) + 1\n  if(endYear <= beginYear) {\n    return(piaBends[piaBends$Year <= endYear, ])\n  } else {\n    awiTemp <- getAwi(endYear = endYear)\n    # Calculate missing bend points using bend point\n    # formula\n    futurePiaBends <-\n      do.call(rbind, lapply((max(piaBends$Year)+1):endYear,\n                            FUN = function(y){\n                              data.frame(Year = y,\n                                         First =\n                                           round(awiTemp[awiTemp$Year == y-2,]$AWI /\n                                                   awiTemp[awiTemp$Year == 1977,]$AWI *\n                                                   piaBends[piaBends$Year == 1979,]$First),\n                                         Second =\n                                           round(awiTemp[awiTemp$Year == y-2,]$AWI /\n                                                   awiTemp[awiTemp$Year == 1977,]$AWI *\n                                                   piaBends[piaBends$Year == 1979,]$Second),\n                                         Third =\n                                           round(awiTemp[awiTemp$Year == y-2,]$AWI /\n                                                   awiTemp[awiTemp$Year == 1977,]$AWI *\n                                                   piaBends[piaBends$Year == 1979,]$Third),\n                                         Formula = c(\"PIA\", \"Maximum\"))\n                            }))\n    piab <- rbind(piaBends, futurePiaBends)\n    piab <- piab[order(piab$Formula, piab$Year), ]\n\n    return(piab)\n  }\n}\n\n\n\n\n#' @export\n# Return Full Retirement Age table to end year\n  getFraSet <- function(endYear = NULL){\n    if(is.null(endYear)) {\n      return(fra)\n    }\n\n    beginYear <- max(fra$`Birth Year`, na.rm = TRUE) + 1\n    if(endYear <= beginYear) {\n      return(fra[fra$`Birth Year` <= endYear,])\n    } else {\n      fraChunk <- data.frame(`Birth Year` = beginYear:endYear,\n                             `Full Retirement Age` = 67,\n                             check.names = FALSE)\n\n      return(rbind(fra, fraChunk))\n    }\n  }\n\n\n\n",
    "created" : 1490884680014.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "433865573",
    "id" : "43ABDCE0",
    "lastKnownWriteTime" : 1490885340,
    "last_content_update" : 1490885340966,
    "path" : "C:/Users/US80375N/Dropbox/oasdir/R/parameters.R",
    "project_path" : "R/parameters.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}